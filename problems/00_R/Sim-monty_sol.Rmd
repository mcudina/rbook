The host knows where the car is and what contestant's guess is. If those two are the same (i.e., contestant guessed right), he will choose one of the two remaining doors at random. If not, he simply shows the contestant the other door with the goat behind it. This exactly what the function `show_door` implements:


```{r}
show_door = function(car, guess) {
   all_doors = c(1,2,3)
   goat_doors = all_doors[ all_doors != car ]
   
   if (car == guess)
   {
      random_goat_door = sample(goat_doors,size=1)
      return(random_goat_door)
   } else {
      the_other_goat_door = goat_doors[ goat_doors != guess ]
      return(the_other_goat_door)
   }
}
```


Next, we write a function which simulates the outcome of a single game. It will have one argument, `switch` which will determine whether the contestant switches the door or not. 


```{r}
one_game = function(switch) {
   all_doors = c(1,2,3)
   car = sample( all_doors, size=1)
   guess = sample( all_doors, size=1)
   
   if (switch) {
      unguessed_doors = all_doors[ all_doors != guess ]
      shown_door = show_door(car, guess)
      switched_guess = unguessed_doors [ unguessed_doors != shown_door]
      return(switched_guess == car) 
   } else {
      return(guess == car)
   }
}
```


Finally we run two batches of $10,000$ simulations, one with `switch=TRUE` and another with `switch=FALSE`:

```{r}
nsim=10000
switch_doors = replicate( nsim,one_game (TRUE))
dont_switch_doors = replicate(nsim, one_game(FALSE))
(prob_with_switching = mean(switch_doors))
(prob_without_switching = mean(dont_switch_doors))

```

Therefore, the probability of winning after switching is about double the probability of winning without switching. Switching is good for you!

(A philosophical note: this was the most "agnostic" approach to this simulation. Simulations can often be simplified with a bit of insight. For example, we could have realized that the switching strategy simply flips the correctness of the guess (from "correct" to "wrong" and vice versa) and used it to write a much shorter answer. Ultimately, we could have realized that, because the probability of the initial guess being correct is $1/3$, switching leads to a correct guess in $2/3$ of the cases (and not switching in only $1/3$ of the cases). In this case, the whole code would be `sample(c("correct", "incorrect"), size=10000, prob= c(2/3,1/3), replacement=TRUE)`, which is an extremely inefficient way to estimate the value of the number $2/3$!)
